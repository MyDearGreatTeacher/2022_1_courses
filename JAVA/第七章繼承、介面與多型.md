## 第七章 繼承、介面與多型
- 繼承  ==> 兒子繼承
  - 單一繼承  vs  多重繼承 
- class vs (Interface)介面
- 多型

## 繼承(Inheritance) == >class 子類別(Subclass) extends 父類別(Superclass)
- 子類別(Subclass) 繼承 父類別(Superclass)
- 單一繼承:一個父類別可以衍生出很多的子類別，但一個子類別只能繼承一個父類別
- 
```java
class CMath {
   public void getMax(int a, int b) {
      int bigNum;
      if (a > b)
         bigNum = a;
      else
         bigNum = b;
      System.out.println(a + " 與 " + b + " 的最大數為 " + bigNum);
   }
}

class SonCMath extends CMath {          // SonCMath繼承CMath類別
   public void getFactorial(int a) {
      int ans = 1, i;
      System.out.print(a + "! = ");
      for (i = 1; i < a; i++) {
         System.out.print(i + "*");
         ans *= i;
      }
      ans *= a;
      System.out.println(a + " = " + ans);
   }
}

public class ExtendDemo {
    public static void main(String[] args) {
	    SonCMath math1 = new SonCMath();
		math1.getMax(10, 20);     // 呼叫子類別繼承父類別的方法
		System.out.println();
		math1.getFactorial(5);    // 呼叫子類別自己的方法
	}
}
```


## 方法覆寫(Override)
- 兒子對於某些方法有自己的看法不採用父親交代的方法


```java
class CMath {
   public void getMax(int a, int b) {
      int bigNum;
      if (a>b) bigNum = a;
      else bigNum = b;
      System.out.println(a + " ㎝ " + b + " 程计 " + bigNum);
   }
}

class SonCMath extends CMath {
   public void getMax(int a, int b) {
   if(a>b)
	  System.out.println(a + " ㎝ " + b + " 程计 " + a);
   else if(a<b)
      System.out.println(a + " ㎝ " + b + " 程计 " + b);
   else
      System.out.println(a + " ㎝ " + b + " 妓");
   }
}

public class OverrideDemo {
   public static void main(String[] args) {
      CMath math3 = new CMath();
	  math3.getMax(20, 20);         //㊣CMath摸getMax()よ猭
	  SonCMath math4 = new SonCMath();
	  math4.getMax(20, 20);         //㊣SonCMath摸getMax()よ猭
   }
}
```

## 預設建構式的執行順序
```java
class CMath {
   protected int a = 1;
   CMath() {
      System.out.println("a = " + a);
   }
}

class SonCMath extends CMath {
   protected int b = 2;
   SonCMath() {
      System.out.println("a + b = " + (a + b));
   }
}

class GrandSonCMath extends SonCMath {
   protected int c = 4;
   GrandSonCMath() {
      System.out.println("a + b + c = " + (a + b + c));
   }
}

public class ConstructorExtend {
	public static void main(String[] args) {
	   new GrandSonCMath();   // 採匿名物件的方式來建立物件實體
	}
}
```

## 7.1.5 使用super
- 讓子類別用來呼叫父類別的建構式
- 在子類別中透過super來呼叫父類別的成員
```JAVA
class CScore {
   private int chia, math;
   CScore() {
      chia = 0; math = 0;
   }

   CScore(int chia, int math) {
      this.chia = chia;
      this.math = math;
   }

   public void showScore() {
      System.out.print("國文：" + this.chia + "\t 數學：" + this.math);
   }
}

class SonCScore extends CScore {
   private int eng;
   SonCScore() {
      super();       //呼叫CScore父類別的CScore()建構式
      eng = 0;
   }
	
   SonCScore(int chia, int math, int eng) {
      //呼叫CScore父類別的CScore(int chia, int math)建構式
      super(chia, math);
      this.eng = eng;
   }
	
   public void showScore() {
      super.showScore();   //呼叫父類別的showScore方法
      System.out.print("\t 英語：" + this.eng);
   }
}

public class SuperDemo {
   public static void main(String[] args) {
	  CScore Peter = new CScore(50, 70);
	  Peter.showScore();
	  System.out.println("\n");
	  SonCScore Tom = new SonCScore(65, 84, 99);
	  Tom.showScore();
   }
}
```
## 7.1.6 使用final
- final 資料成員: 常數
  - 當使用final來宣告一個常數時，記得一定要同時給予這個常數初值(常數的值不能被變更的)。
- final 方法成員: 這個方法不可以被子類別覆寫。
  - 如果父類別的某個方法成員前面加上了final保留字，則子類別又有相同名稱的方法成員的話，編譯時期就會出現錯誤。
- final class:該類別無法被繼承。

```JAVA
final class Cdog  {    //無法被繼承
   int weight ;
}

/* 因為Cdog類別為final，所以Ccat無法繼承Cdog
class Ccat extends Cdog { }
*/

class Ccar {
   //private final int speed;   //此寫法錯誤,必須指定初值
   private final int speed = 120 ;
   public final void showBigSpeed(String s) {
      System.out.println(s + " 最大速度是 " + speed + " 公里！");
   }
}

class PiliCcar extends Ccar {
   /* 父類別的showBigSpeed方法為final，所以子類別無法覆寫
   public void showBigSpeed(String s) {
      System.out.println(s + " 最大速度是 " + speed + " 公里！");
   }
   */
}

public class FinalDemo1 {
   public static void main(String[] args) {
      Ccar car1 = new Ccar();
	  car1.showBigSpeed("car1");
      PiliCcar car2 = new PiliCcar();
      car2.showBigSpeed("car2");
   }
}
```

