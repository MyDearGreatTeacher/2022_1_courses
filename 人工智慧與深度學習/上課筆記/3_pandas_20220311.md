### pandas
- [經典:Python 資料分析, 2/e](https://www.tenlong.com.tw/products/9789864769254)
  - [GITHUB](https://github.com/wesm/pydata-book) 
  - [中譯](https://github.com/LearnXu/pydata-notebook/tree/master/)
- [Pandas 資料分析實戰：使用 Python 進行高效能資料處理及分析 (Learning pandas : High-performance data manipulation and analysis in Python, 2/e) Michael Heydt ](https://www.tenlong.com.tw/products/9789864343898)
- [Python 資料分析必備套件！Pandas 資料清理、重塑、過濾、視覺化 (Pandas 1.x Cookbook, 2/e) Matt Harrison、Theodore Petrou](https://www.tenlong.com.tw/products/9789863126898?)
- [深入淺出 Pandas：利用 Python 進行數據處理與分析 李慶輝　著](https://www.tenlong.com.tw/products/9787111685456)

## 
```
# -*- coding: utf-8 -*-


tup = 4, 5, 6
tup

"""如果想要創建一個更複雜的tuple的話，還是要用括弧，括弧之間還是用逗號："""

nested_tup = (4, 5, 6), (7, 8)
nested_tup

"""把其他序列或反覆運算器轉換為序列："""

tuple([4, 0, 2])

tup = tuple('string')
tup

"""存放在tuple中的object本身無法更改："""

tup = tuple(['foo', [1, 2], True])
tup[2] = False

"""但是如果tuple內部的object是可更改的，那麼我們可以試著更改一下："""

tup[1].append(3)
tup

"""用+來合併多個tuple："""

(4, None, 'for') + (6, 0) + ('bar', )

"""`*` 相當於copy多份，也可以用在list上："""

('foo', 'bar') * 4

"""## Unpacking tuples(取出元組)"""

tup = (4, 5, 6)
a, b, c = tup

b

tup = 4, 5, (6, 7)
a, b, (c, d) = tup

d

"""用下面的方法來交換變數的名字:"""

tmp = a
a = b 
b = tmp

"""但是在python裡，交換能更簡潔一些："""

b, a = a, b

"""這種unpacking通常用在反覆運算序列上："""

seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]

for a, b, c in seq:
    print('a={0}, b={1}, c={2}'.format(a, b, c))

"""另一種更高級的unpacking方法是用於只取出tuple中開頭幾個元素，剩下的元素直接賦給`*rest`："""

values = 1, 2, 3, 4, 5
a, b, *rest = values

a, b

rest

"""rest部分是你想要丟棄的，名字本身無所謂，通常用底線來代替："""

a, b, *_ = values

"""## Tuple methods(元組方法)

因為tuple的大小和內容都不能改變，所以方法也很少。`count`用來計算某個值出現的次數，list中也有這個方法：
"""

a = (1, 2, 2, 2, 3, 4, 2)
a.count(2)

"""# 2 List (列表)

清單的靈活性就很強了，大小和內容都可以變：
"""

a_list = [2, 3, 7, None]
tup = ('foo', 'bar', 'baz')

b_list = list(tup)
b_list

b_list[1] = 'peekaboo'
b_list

"""list函數通常用來具現化反覆運算器或生成器："""

gen = range(10)
gen # 這是一個反覆運算器，所以無法看到裡面的內容

list(gen) # 具現化後就可以看到了

"""## 添加和移除元素"""

b_list.append('dwarf')
b_list

"""insert可以把元素插入到特定的位置："""

b_list.insert(1, 'red')
b_list

"""需要注意的是insert方法運算量比append大。所以如果想要在序列的開頭和結尾添加元素的話，可以使用collections.deque，這是一種雙結尾的佇列

insert的反向操作較pop, 能移除序列中特定位置的元素：
"""

b_list.pop(2)

b_list

"""remove可以通過值移除指定的element，如果同一個值在序列中多次出現，只移除第一個："""

b_list.append('foo')
b_list

b_list.remove('foo')
b_list

"""檢查一個值是否在list中，用in："""

'dwarf' in b_list

'dwarf' not in b_list

"""## 合併list

用 + 號：
"""

[4, None, 'foo'] + [7, 8, (2, 3)]

"""通過entend方法，可以添加多個元素："""

x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
x

"""注意：用+法來做合併是一個運算量較大的操作，因為要創建一個新的list並複製。如果操作的是一個很大的list，用extend會更好一些："""

everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
    
# 上面的代碼要比下面的快

everything = []
for chunk in list_of_lists:
    everything = everything + chunk

"""這裡總結一下，首先是append和extend的區別。
- append是把元素添加到一個list裡
- extend是把兩個list結合在一起

然後是extend和+的區別
- `+`是創建了一個新的list並返回，運算量大
- extend是在原本的list上做了更改，運算量小

## 排序

用sort函數
"""

a = [7, 2, 5, 1, 3]
a.sort()
a

"""sort函數有一些比較方便的選項。比如設置一個sort key，這個key也是一個函數（funciton）。比如我們想要按string的長度來排序："""

b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
b

"""## Binary search and maintaining a sorted list （二分搜索和維持一個排好序的list）

內建的bisect模組可以實現二分搜索。`bisect.bisect`是用來尋找插入的位置，而`bisect.insort`則實際插入元素到指定的位置：
"""

import bisect
c = [1, 2, 2, 2, 3, 4, 7]

bisect.bisect(c, 2)

bisect.bisect(c, 5)

bisect.insort(c, 6)
c

"""注意：bisect模組不會檢查list是否是排好序的，所以用這個模組之前要先把list排序。

## Slicing (切片)

[start:stop], 輸出的結果包含開頭，不包含結尾。所以輸出的結果的數量是stop-start
"""

seq = [7, 2, 3, 7, 5, 6, 0, 1]
seq[1:5]

"""可以賦值："""

seq[3:4] = [6, 3]

seq # 把元素7變成了6, 3

"""可以不用寫開頭或結尾："""

seq[:5]

seq[3:]

"""負索引表示倒數開始多少個的意思："""

seq[-4:]

seq[-6:-2]

"""兩個冒號後面的數代表步長，就是隔幾個元素取一次："""

seq

seq[::2]

"""用-1能反轉一個list或tuple："""

seq[::-1]

"""切片方式：

![](../MarkdownPhotos/chp03/螢幕擷取畫面 2017-10-25 下午1.59.36.png)

# 3 Built-in Sequence Functions(內建的序列函數)

## enumerate（枚舉）
這個通常用於反覆運算序列。一個比較直白的方法是：
"""

i = 0
for value in collection:
    # do something with value
    i += 1

"""但enumerate能返回一個(i, value)的tuple："""

for i, value in enumerate(collection):
    # do something with value

"""enumerate通常用來把一個list中的位置和值映射到一個dcit字典裡："""

some_list = ['foo', 'bar', 'baz']
mapping = {}

for i, v in enumerate(some_list):
    mapping[v] = i

mapping

"""## sorted

sorted函數返回一個新的排好序的序列，而之前提到的.sort方法是直接更改原有的序列，不產生新序列：
"""

sorted([7, 1, 2, 6, 0, 3, 2])

sorted('horse race')

"""## zip

用於"pairs"(成對)。把多個序列中每個對應的元素變成一對，最後返回一個含有tuple的list：
"""

seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']

zipped = zip(seq1, seq2)
zipped

list(zipped)

"""zip可以接收任意長度的序列，最後返回的結果取決於最短的序列："""

seq3 = [False, True]
list(zip(seq1, seq2, seq3))

"""zip的一個常見用法是同時反覆運算多個序列，可以和enumerate搭配起來用："""

for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))

"""如果給我們一個壓縮過的序列，我們可以將其解壓："""

pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'), 
            ('Schilling', 'Curt')]

first_names, last_names = zip(*pitchers)

first_names

last_names

"""## reversed

reverse可以倒敘反覆運算序列：
"""

list(reversed(range(10)))

"""注意，revered是一個generator（生成器，之後會詳細講），所以必須需要list來具現化

# 4 dict（字典）

字典也被叫做hash map 或 associative array。結構就是key-value pairs.創建方式是用`{}`:
"""

empty_dict = {}

d1 = {'a': 'some value', 'b': [1, 2, 3, 4]}

d1

"""dict像list一樣可以插入："""

d1[7] = 'an integer'
d1

"""可以檢查dict是否有某個key："""

'b' in d1

"""可以用del或pop刪除值："""

d1[5] = 'some value'
d1

del d1[5]

d1

d1['dummy'] = 'another value'
d1

ret = d1.pop('dummy')

ret

d1

"""keys和values方法能返回dict中key-value組合的反覆運算器，不過並不安什麼順序。如果想讓keys和values每次列印的順序相同的話："""

list(d1.keys())

list(d1.values())

"""可以用update來合併兩個dict："""

d1.update({'b': 'foo', 'c': 12})

d1

"""這個update是更改了原有的dict，不會返回新的dict

## Creating dicts from sequences（從序列中生成dict）

假設我們想把兩個序列按照key-value的方式生成一個dict，我們可能會這樣寫：
"""

mapping = []
for key, value in zip(key_list, value_list):
    mapping[key] = value

"""因為dict其實就是2-tuple的組合，所以dict函數能接受一組2-tuple："""

mapping = dict(zip(range(5), reversed(range(5))))

mapping

"""## Default value(預設值)

如果dict中某個key存在的話，就返回該value，否則的話，就返回一個預設值：
"""

if key in some_dict:
    value = some_dict[key]
else:
    value = default_value

"""不過dict中的get和pop方法能設置預設值，即能把上面的代碼簡寫為："""

value = some_dict.get(key, default_value)

"""如果key不存在的話，get方法默認會返回None，而pop則會引發一個錯誤。

通過設定值，一個常用的場景是一個dict中的value也是其他集合，比如list。舉例說明，我們想要把一些單詞按首字母歸類：
"""

words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}

for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)

by_letter

"""而setdefault方法則是專門為這個用途存在的，上面的迴圈可以寫為："""

for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)

"""使用setdefault() 初始化字典鍵值. 使用字典的時候經常會遇到這樣一種應用場景：動態更新字典，像如上面代碼，如果key不在dictionary 中那麼就添加它並把它對應的值初始為空列表[] ，然後把元素append到空清單中。

內建的collections模組有一個有用的class，defaultdict，這個能讓上述過程更簡單。創建方法是傳遞一個type或是函數：


"""

from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)

"""## Valid dict key types(有效的key類型)

通常key的類型是不可更改的常量類型（int，float，string）或tuple。專業的叫法是hashability。可以查看一個object是否是hashable，只要是hashable的，就可以當做dict中的key。這裡用hash函數查看：
"""

hash('string')

hash((1, 2, (2, 3)))

hash(1, 2, [2, 3]) # 失敗，因為list是可變的

"""要想把list當做key的話，可以把list轉變為tuple："""

d = {}
d[tuple([1, 2, 3])] = 5

d

"""## 5 Set 集合

set是無序且元素不重複的。就像是key唯一，且沒有value的字典。兩種方式可以創建，一個是用set函數，一個是用花括弧：
"""

set([2, 3, 2, 1, 4, 4, 3])

{2, 3, 2, 1, 4, 4, 3}

"""集合的操作既然也支援，比如並集，交集，差集："""

a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}

# 並集
a.union(b)

a | b

# 交集
a.intersection(b)

a & b

"""一些集合操作
![](../MarkdownPhotos/chp03/螢幕擷取畫面 2017-10-25 下午2.01.37.png)

上面這些邏輯操作都是直接更改set本身。如果是一個很大的set，下面的操作會更有效率：
"""

c = a.copy()
c |= b
c

d = a.copy()
d &= b
d

"""set的元素必須是不可更改的。如果想要list一樣的元素，只能變為tuple："""

my_data = [1, 2, 3, 4]
my_set = {tuple(my_data)}
my_set

"""我們可以查看一個子集與父集的關係："""

a_set = {1, 2, 3, 4, 5}

{1, 2, 3}.issubset(a_set)

a_set.issuperset({1, 2, 3})

"""# 6 List, Set, and Dict Comprehensions(推導式)

list comprehension(列表推導式）是python裡最受喜愛的一個特色。我們能簡潔地構造一個list：

    [expr for val in collection if condiction]
相當於：

    result = []
    for val in collection:
        if condition:
            result.append(expr)
            
比如，給定一個list，裡面有很多string，我們只要留下string長度超過2的，並將其轉換為大寫：
"""

strings = ['a', 'as', 'bat', 'car', 'dove', 'python']

[x.upper() for x in strings if len(x) > 2]

"""dict推導式：

`dict_comp = {key-expr: value-expr for value in collection if condition}`

set的推導式：

`set_comp = {expr for value in collection if condition}`

基於上面的例子，我們想要一個集合來保存string的長度：
"""

unique_length = {len(x) for x in strings}
unique_length

"""用map讓表達更功能化一些："""

set(map(len, strings))

"""一個簡單而的字典運算式例子，string和其在list中對應的index："""

loc_mapping = {val: index for index, val in enumerate(strings)}

loc_mapping

"""## Nested list comprehensions（嵌套列表運算式）

假設我們有一個list，list中又有不同的list表示英語和西班牙語的姓名：
"""

all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'], 
            ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]

"""我們想要按語言來組織這些名字。可以用一個for loop："""

names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') >= 2]
    names_of_interest.extend(enough_es)

names_of_interest

"""但是我們key用嵌套列表運算式寫得更簡潔一些："""

result = [name for names in all_data for name in names if name.count('e') >= 2]

result

"""for部分是根據嵌套的順序來寫的，從外層的loop到內層的loop。這裡一個例子是把tuple扁平化成一個整數清單："""

some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
flattened = [x for tup in some_tuples for x in tup]
flattened

"""一定要記住順序是和我們寫for loop一樣的："""

flatteded = []

for tup in some_tuples:
    for x in tup:
        flattened.append(x)

"""列表運算式裡再有一個列表運算式也是可以的，可以生成a list of lists："""

[[x for x in tup] for tup in some_tuples]

```
